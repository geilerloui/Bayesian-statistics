set.seed(34)
n = 100
x = numeric(n)
for (i in 2:n) {
x[i] = rnorm(1, mean=x[i-1], sd=1.0)
}
plot.ts(x)
set.seed(34)
n = 100
x = numeric(n)
for (i in 2:n) {
x[i] = rnorm(1, mean=x[i-1], sd=1.0)
}
plot.ts(x)
set.seed(34)
n = 100
x = numeric(n)
for (i in 2:n) {
x[i] = rnorm(1, mean=x[i-1], sd=1.0)
}
plot.ts(x)
Q = matrix(c(0.0, 0.5, 0.0, 0.0, 0.5,
0.5, 0.0, 0.5, 0.0, 0.0,
0.0, 0.5, 0.0, 0.5, 0.0,
0.0, 0.0, 0.5, 0.0, 0.5,
0.5, 0.0, 0.0, 0.5, 0.0),
nrow=5, byrow=TRUE)
Q %*% Q # Matrix multiplication in R. This is Q^2.
(Q %*% Q)[1,3]
Q5 = Q %*% Q %*% Q %*% Q %*% Q # h=5 steps in the future
round(Q5, 3)
Q10 = Q %*% Q %*% Q %*% Q %*% Q %*% Q %*% Q %*% Q %*% Q %*% Q # h=10 steps in the future
round(Q10, 3)
Q30 = Q
for (i in 2:30) {
Q30 = Q30 %*% Q
}
round(Q30, 3) # h=30 steps in the future
c(0.2, 0.2, 0.2, 0.2, 0.2) %*% Q
n = 5000
x = numeric(n)
x[1] = 1 # fix the state as 1 for time 1
for (i in 2:n) {
x[i] = sample.int(5, size=1, prob=Q[x[i-1],]) # draw the next state from the intergers 1 to 5 with probabilities from the transition matrix Q, based on the previous value of X.
}
table(x) / n
set.seed(38)
n = 1500
x = numeric(n)
phi = -0.6
for (i in 2:n) {
x[i] = rnorm(1, mean=phi*x[i-1], sd=1.0)
}
plot.ts(x)
hist(x, freq=FALSE)
curve(dnorm(x, mean=0.0, sd=sqrt(1.0/(1.0-phi^2))), col="red", add=TRUE)
legend("topright", legend="theoretical stationary\ndistribution", col="red", lty=1, bty="n")
